Первое и самое главное: "координаты" строк в текстовом пространстве:
XY_pos(item_num) = (8, 4+16*item_num)

Структура хранения данных в EEPROM


1) Нулевой байт eeprom отведен для стандартных булевых значений. и имеет вид 0bABCDEFGH
H - происходила ли инициализация 
G - было ли аварийное выключение
F - вкл/выкл звук 
E - определяет идет работа по предустановленному циклу (E=false) или по программе (E = true)
D - определяет установлен ли режим безопасного торможения (D=true - установлен)
            +---+---+---+------+------+-------+-------+------+
byte: 0x00  | 7 | 6 | 5 | 4    | 3    | 2     | 1     | 0    |
            +---+---+---+------+------+-------+-------+------+
            | - | - | - | SAFE | PROG | SOUND | EMERG | INIT |
            +---+---+---+------+------+-------+-------+------+

2) Первый байт отведен для установки 
яркости монитора (0-255) (реально межно было бы запихнуть в 4-7 байт бита 0x00)

3) Второй-третий байт хранит информацию о количестве пройденых режимов и то, на каком этапе мы находимся 
Пусть максимальное количество режимов повторения составляет 999. Для хранения этого числа необходимо два байта (реально 10 бит).
остается шесть (0-15) - для описания номера этапа достаточно первых трех и четвертый будет обозначать направление 
NUM(X) = num_of_elapsed_cycles, STATE(X) = curr_vel_cycle_state
            +-------+-------+-------+--------+--------+--------+------+------+------+------+------+------+------+------+------+------+
byte:       | 15 (3)| 14 (3)| 13 (3)| 12 (3) | 11 (3) | 10 (3) | 9 (3)| 8 (3)| 7 (2)| 6 (2)| 5 (2)| 4 (2)| 3 (2)| 2 (2)| 1 (2)| 0 (2)|
0x03\/0x02  +-------+-------+-------+--------+--------+--------+------+------+------+------+------+------+------+------+------+------+
            |   -   |   -   |  DIR  | STATE2 | STATE1 | STATE0 | NUM9 | NUM8 | NUM7 | NUM6 | NUM5 | NUM4 | NUM3 | NUM2 | NUM1 | NUM0 |
            +-------+-------+-------+--------+--------+--------+------+------+------+------+------+------+------+------+------+------+

Четвертый байт хранит номер последней программы и точки, на которой система остановилась  (в случае если PROG = 0 информация не 
имееет смысла). Запись ведется только если детектировано аварийное отключение и бит PROG в байте 0x00 равен 1
            +-----+-----+-----+-----+---+-------+-------+-------+
byte: 0х04  | 7   | 6   | 5   | 4   | 3 | 2     | 1     | 0     |
            +-----+-----+-----+-----+---+-------+-------+-------+
            | PT3 | PT2 | PT1 | PT0 | - | PNUM2 | PNUM1 | PNUM0 |
            +-----+-----+-----+-----+---+-------+-------+-------+

4) для режима перемешивания:
пусть данные начинаются с start_byte и каждая целая величина занимает SIZE_OF_DATA байт (1 или 2)
тогда 
t_accel лежит в start_byte
v_const лежит в start_byte + SIZE_OF_DATA
t_const  лежит в start_byte + 2*SIZE_OF_DATA
t_slowdown лежит в start_byte + 3*SIZE_OF_DATA
t_pause лежит в start_byte + 4*SIZE_OF_DATA
num_cycles  лежит в start_byte + 5*SIZE_OF_DATA
is_accel_smooth , is_bidirectional лежат соответственно в первом и втором бите байта находящегося 
по адресу start_byte + 6*SIZE_OF_DATA (напр 0b00000010 эквивалентен is_accel_smooth = false , 
is_bidirectional = true)
Таким образом, все данные занимают 5*SIZE_OF_DATA + 1 байт

5) Данные о программах. 
Участок памяти начинается с байта PROG_FIRST_BYTE = START_BYTE + 5*SIZE_OF_DATA + 1 + 1 (последняя единица чисто так на всякий случай)
Для конфигурации на момент 12.05 это байт с адресом 16.
Структура хранения: у нас будет 8 программ по 16 точек с пятью двухбайтовыми значениями на каждый
(программа 0){(точка 0){0,1,2,3,4},(точка 1){0,1,2,3,4},...,(точка 15){0,1,2,3,4}},{программа 1},..,{программа 7}
таким образом: 
адресс k-программы это PROG_FIRST_BYTE + 5*k*SIZE_OF_DATA*NUM_OF_POINTS (вероятно)
адресс l-точки в k-программе это PROG_FIRST_BYTE + 5*k*SIZE_OF_DATA*NUM_OF_POINTS + 5*l*SIZE_OF_DATA (вероятно)
адресс m-параметра в l-точке в k-программе это PROG_FIRST_BYTE + 5*k*SIZE_OF_DATA*NUM_OF_POINTS + 5*l*SIZE_OF_DATA + m*SIZE_OF_DATA (вероятно)

ТАЙМЕР ПРЕРЫВАНИЙ
Работа шагового двигателя происходит в прерываниях от таймера timer1 . Масштабный параметр определяет частоту с 
которой корректируется работа и является делителем
Системный таймер 16МГц, т.е. период прерываний без множителей равен MAX_VALUE/16MHz = 62500/16*10^9 = 1/256 ~ 4мс (256 обновлений/c)
а на выбор доступны множители: 
CS3 CS2 CS1 = {001 (х1, 256 обн/с, 3.9мс), 010 (х8, 32 об/с, 31мс), 011 (х64, 4 об/с, 250мс), 100 (х256, 1 об/с), 101 (х1024, 0.25 об/с)}  
Период таймера (по сути, период обработки и обновления скорости в милисекундах) определяется параметром 
TIMER_PERIOD (на 15.05 = 1000). время (в милисекундах) пишется в time_elapsed и 
обновляется в прерываниях. Это глобальная переменная, так что ее может получить
любая функция. ВАЖНО: Она представляет собой uint32_t, так что ее хватит примерно 
на 50 суток.

TODO: РАБОТА ДВИГАТЕЛЯ
Во всех менюшках в while должна находиться функция update_speed(), которая 
должна сначала проверять ведется ли работа, а также проверять мы действуем по режиму 
программирования или по одиночному запуску проверяя булево working_in_programming_mode
дальше, на основании текущего времени (или переменной, хранящей информацию о текущем 
этапе режима) обновлять задачу для двигателя и отправлять новую команду скорости.
Идея использовать elapsed_time для того, чтобы понимать на каком этапе мы находимся,
вычислять переменную с временем в текущем режиме и рассчитывать скорость
по формуле 

float p = (t / T);
v_curr = v_start + (v_end-v_start) * p*p*(3-2*p); , где v_i - частота вращения
или если мы говорим про абсолютные углы:
phi_curr = [t*(v_start + (v_end-v_start) * p*p*(1 -p / 2))] -> [0,2pi)
также можно пересчитать и в относительные. Это довольно несложно
Альтернатива: зная текущую и вычисляя целевую скорость по этой формуле, представляем этот
участок как равноускоренный и если эта функция описана в либах, то я буду иметь (вполне)
гладкое движение

ЭКРАН 
По состоянию на 16.05 обновление экрана oled.update() занимает около 0.12c, т.е. фактическая частота обновления составляет около 
8 кадров в секунду. Причем, скорее всего это связано со свойствами самой либы, а значит это не исправить простой оптимизацией.
На это не влияет (по крайней мере, пока) логика прерываний, так как и прерывания раз с периодом 10/1/0.1 с дают один и тот же результат
однако объем данных незначительно меняет период обновлений, так как экран заполненный текстом обновляется раз в 0.14с 
(при этом полностью заполненный прямоугольник делает это за 0.13с, т.е. тут есть совокупность скорости рендеринга и скорости отправки
данных). 
TODO: Если это будет вызывать проблемы, то возможно прийдется перейти на другую либу; 

TODO: добавить функцию экстренного сохраниения информации о режиме работы, программе и текущем этапе выполнения в случае
прерывания с аналогового пина

УСТАНОВКА СКОРОСТИ 
Скорость curr_v является глобальной float величиной. Ее изменение происходит вутри прерывания ISR которое запускается при переполнении 
регистра TIMER1 и срабатывает с периодом TIMER_PERIOD. В нем спрятана логика остановки по команде пользователя, работы в режиме ручного 
запуска и работы в програмном режиме. Возможно, в дальнейшем, отправка команды на контроллер будет происходить не из прерывания, но пока
управление двигателем ведется там-же. Для более подробного описания см. комментарии внутри ISR(TIMER1_COMPA_vect)
В режиме ожидания прерывание занимает 4 мкс, при ускорении, на одно прерывание требуется 92-96 мкс ( < 10^(-4) c), и при остановке процесса 
требуется ~60 мкс. Таким образом, при периоде вызова прерывания в 10 мс. Таким образом, в самые загруженные моменты, установка скорости 
занимает меньше 1% (1000/10*92/1000000*100 = 0.92%) времени, что достаточно неплохо


3446 339 3785 678: 0000110101110110  0000000101010011  0000111011001001  0000001010100110
40 140 240 340: 0000000000101000  0000000010001100